# Leetcode 101

## 贪心算法

贪心算法或贪心思想采用贪心的策略，保证每次操作都是局部最优的，从而使最后得到的结果是全局最优的。

在每个人身上都是**局部最优**的。又因为全局结果是局部结果的**简单求和**，且局部结果**互不相干**，因此局部最优的策略也同样是全局最优的策略。

### 455.Assign Cookies(E)

#### 关于sort函数

void sort (**RandomAccessIterator** first, **RandomAccessIterator** last, Compare comp);

Sorts the elements in the range `[first,last)` into ascending order.

The elements are compared using `operator<` for the first version, and comp for the second.

```c++
std::sort (myvector.begin(), myvector.end(), myobject); 
```

常用的数组排序方式见上，由于`[first,last)`，所以涉及到的`vetcor`容器中，`vector.end()`返回的iterator是所有元素的下一位。

### 135.Candy(H)

做完了题目 455，会不会认为存在比较关系的贪心策略一定需要排序或是选择？虽然这一道题也是运用贪心策略，但我们只需要简单的两次遍历即可。

事实上本题采用双遍历的贪心算法会带来O(n)的空间复杂度，若通过讨论递增递减数列的长度可以优化至O(1)，不过较难以理解。

其中关于递减递增序列的转换需要点思维强度，考虑一下 [3, 4, 9, 8, 7, 6] 的排列。

### 435.Non-overlapping Intervals (M)

这题用贪心的解法我想出来了，但和标答有一些差别

对于区间重叠问题，转换为预定会议问题会好理解许多：给你若干时间的会议，然后去预定会议，那么能够预定的最大的会议数量是多少？核心在于我们要找到最大不重叠区间的个数。 如果我们把本题的区间看成是会议，那么按照右端点排序，我们一定能够找到一个最先结束的会议，而这个会议一定是我们需要添加到最终结果的的首个会议。（通过贪心算法，找到右端点排序的第一区间永远可以计入，因为这样侵占其他会议的时间最少。若有冲突则找下一个会议，否则将下个会议的结束时间记录。

而按照左端点排序的话，最先开始的会议未必最先结束，可能会有大会议侵占会议数量

（这里我的想法是左端点排序正序遍历，每次冲突删去最大区间的做法也是正解）

*有一个问题，就是在101里记录的c++ lambda函数特性（就是之前看不懂的`[]()`等函数）会莫名其妙的爆超时，可能是lc没法解析吧

我在解题的时候很明显受到了python的影响，上去就是一个函数嵌套定义def+def，在c++里面是不可以出现函数嵌套定义的，解决方法是lambda短时函数（或者在leetcode里可以通过在类内构造其他静态函数来解决）